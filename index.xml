<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>David Zager&#39;s Blog</title>
    <link>https://djzager.github.io/</link>
    <description>Recent content on David Zager&#39;s Blog</description>
    <generator>Hugo - gohugo.io</generator>
    <language>en</language>
    <contact>david.j.zager@gmail.com</contact>
    <copyright>&copy; <a href="https://github.com/djzager">David Zager</a> 2017</copyright>
    
        <atom:link href="https://djzager.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Reaching for the Stars with Ansible Operator</title>
      <link>https://djzager.github.io/posts/3-reaching-for-the-stars/</link>
      <pubDate>Sat, 02 Mar 2019 21:50:22 +0000</pubDate>
      <author>David Zager</author>
      <guid>https://djzager.github.io/posts/3-reaching-for-the-stars/</guid>
      <description>Using Ansible Galaxy to create Kubernetes native applications</description>
      
      <content>

&lt;p&gt;My copy of the post on the &lt;a href=&#34;https://blog.openshift.com/reaching-for-the-stars-with-ansible-operator/&#34; target=&#34;_blank&#34;&gt;Red Hat OpenShift Blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this post I will show you how to use Roles published to &lt;a href=&#34;https://galaxy.ansible.com&#34; target=&#34;_blank&#34;&gt;Ansible Galaxy&lt;/a&gt; as an Operator to manage an application in Kubernetes. Reusing a Role in this way provides an example of how to create an Operator that simply installs an application with the flexibility to expand and customize the behavior organically as requirements dictate.&lt;/p&gt;

&lt;p&gt;I will leverage both the &lt;a href=&#34;https://github.com/operator-framework/operator-sdk/blob/master/doc/ansible/user-guide.md&#34; target=&#34;_blank&#34;&gt;Ansible Operator&lt;/a&gt; and the &lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/k8s_module.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;k8s&lt;/code&gt; module&lt;/a&gt; to demonstrate how you can use Ansible to create Kubernetes native applications. Ansible Operator, included in the &lt;a href=&#34;https://github.com/operator-framework/operator-sdk&#34; target=&#34;_blank&#34;&gt;Operator SDK&lt;/a&gt;, allows you to package your operational knowledge (how you install and maintain your application) in the form of Ansible Roles and Playbooks. Your ability to manage objects in Kubernetes when writing these Roles and Playbooks can be improved by the new &lt;code&gt;k8s&lt;/code&gt; module.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Spoiler Alert&lt;/strong&gt; Yes. It can be this easy to create an operator.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM quay.io/operator-framework/ansible-operator

RUN ansible-galaxy install djzager.hello_world_k8s

RUN echo $&#39;--- \n\
- version: v1alpha1\n\
  group: examples.djzager.io\n\
  kind: HelloWorld\n\
  role: /opt/ansible/roles/djzager.hello_world_k8s&#39; &amp;gt; ${HOME}/watches.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;First, if you are reading this and are not aware of the &lt;code&gt;k8s&lt;/code&gt; &lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/k8s_module.html&#34; target=&#34;_blank&#34;&gt;Ansible Module&lt;/a&gt; you should take a look. Introduced in Ansible 2.6, this module is designed to improve your ability to work with Kubernetes objects in Ansible in any Kubernetes distribution, including Red Hat OpenShift. &lt;a href=&#34;https://www.ansible.com/blog/dynamic-kubernetes-client-for-ansible&#34; target=&#34;_blank&#34;&gt;This post on the Ansible blog&lt;/a&gt; introduces the &lt;code&gt;k8s&lt;/code&gt; module and the &lt;a href=&#34;https://github.com/openshift/openshift-restclient-python&#34; target=&#34;_blank&#34;&gt;Red Hat OpenShift dynamic python client&lt;/a&gt;. The dynamic client simply put, in my opinion, if you are interacting with Kubernetes objects in Ansible and are not using the &lt;code&gt;k8s&lt;/code&gt; module, you are doing it wrong.&lt;/p&gt;

&lt;p&gt;Operators are purpose built to run a Kubernetes application, and the Operator SDK provides the tools to build, test, and package them. Ansible Operator exists to help you encode the operational knowledge of your application in Ansible. The workflow is designed to be simple; use &lt;code&gt;operator-sdk new --type=Ansible&lt;/code&gt; to generate the necessary bits for an Ansible based Operator, add Ansible, and &lt;code&gt;operator-sdk build&lt;/code&gt; you have an application built to run in Kubernetes. But if you already have a Role in Galaxy that manages your application in Kubernetes, it can be easier.&lt;/p&gt;

&lt;p&gt;In this post I will:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Build an Ansible Role for managing a Hello World application in Kubernetes. This role will highlight what I believe makes the Ansible &lt;code&gt;k8s&lt;/code&gt; module powerful.&lt;/li&gt;
&lt;li&gt;Publish my Role to Ansible Galaxy.&lt;/li&gt;
&lt;li&gt;Build an Ansible Operator using my Role published to Galaxy.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Why would you use an Ansible Role from Galaxy to make an Operator? There are two reasons:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&#34; target=&#34;_blank&#34;&gt;Don&amp;rsquo;t repeat yourself&lt;/a&gt;. Once I have written an Ansible Role for managing the Hello World application and published it to Ansible Galaxy, I would consume this with Ansible Operator when creating an Operator.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Separation_of_concerns&#34; target=&#34;_blank&#34;&gt;Separation of Concerns&lt;/a&gt;. I want the Hello World Ansible Role to manage the application in Kubernetes and the operational logic to stay with the Operator. The operational logic in this example is designed to be simple, whenever a &lt;code&gt;HelloWorld&lt;/code&gt; custom resource is created or modified, call the &lt;code&gt;djzager.hello_world_k8s&lt;/code&gt; Role. However, &lt;a href=&#34;#next-steps&#34;&gt;in the future&lt;/a&gt; this separation becomes more important. For example, adding validation for my Hello World application would be a solid addition to the Ansible Role, while managing the status of the &lt;code&gt;HelloWorld&lt;/code&gt; custom resource would be operational logic specific to my Operator.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;hello-kubernetes-meet-ansible&#34;&gt;Hello Kubernetes, Meet Ansible&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Pre-Requisites&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Ansible - See the &lt;a href=&#34;https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html&#34; target=&#34;_blank&#34;&gt;installation guide&lt;/a&gt; if you do not already have Ansible installed.&lt;/li&gt;
&lt;li&gt;[Optional] OpenShift python client. Only need this if you want to run locally. The installation instructions can be found &lt;a href=&#34;https://github.com/openshift/openshift-restclient-python#installation&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s get started. The first thing I will do is use &lt;code&gt;ansible-galaxy&lt;/code&gt; to create the Role skeleton:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# I like clear names on projects.
# In meta/main.yml I will make role_name: hello-world-k8s
$ ansible-galaxy init ansible-role-hello-world-k8s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing I like to do when creating a new Ansible Role is define all of my default values. This also serves as a way of documenting the possible configuration options for the Role, fortunately our Hello World example is not particularly complex. Here is my &lt;code&gt;defaults/main.yml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
# NOTE: meta.name(space) comes from CR metadata when run with Ansible Operator
# deploy/crds has an example CR for reference
name: &amp;quot;{{ meta.name | default(&#39;hello-world&#39;) }}&amp;quot;
namespace: &amp;quot;{{ meta.namespace | default(&#39;hello-world&#39;) }}&amp;quot;
image: docker.io/ansibleplaybookbundle/hello-world:latest

# To uninstall from the cluster
# state: absent
state: present

# The size of the hello-world deployment
size: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once I have defined my default values I want to answer what this Role is going to do. My Hello World application needs:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;To get information about the available APIs in the cluster.&lt;/li&gt;
&lt;li&gt;Render a few templates and make sure they are either &lt;code&gt;present&lt;/code&gt; or &lt;code&gt;absent&lt;/code&gt; in the cluster.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;My &lt;code&gt;tasks/main.yml&lt;/code&gt; looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---

- name: &amp;quot;Get information about the cluster&amp;quot;
  set_fact:
    api_groups: &amp;quot;{{ lookup(&#39;k8s&#39;, cluster_info=&#39;api_groups&#39;) }}&amp;quot;

- name: &#39;Set hello-world objects state={{ state }}&#39;
  k8s:
    state: &#39;{{ state }}&#39;
    definition: &amp;quot;{{ lookup(&#39;template&#39;, item.name) | from_yaml }}&amp;quot;
  when: item.api_exists | default(True)
  loop:
    - name: deployment.yml.j2
    - name: service.yml.j2
    - name: route.yml.j2
      api_exists: &amp;quot;{{ True if &#39;route.openshift.io&#39; in api_groups else False }}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before I show off the templates, I want to call attention to one line from my tasks file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;api_exists: &amp;quot;{{ True if &#39;route.openshift.io&#39; in api_groups else False }}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I use a &lt;code&gt;set_fact&lt;/code&gt; to collect all of the available APIs in the cluster and this allows me to selectively render the template if a particular API is available, in this case &lt;code&gt;route.openshift.io&lt;/code&gt;. Routes in OpenShift are not available by default in a Kubernetes cluster and I don&amp;rsquo;t &lt;em&gt;need&lt;/em&gt; them, so I only manage the Route object when the &lt;code&gt;route.openshift.io&lt;/code&gt; API is present.&lt;/p&gt;

&lt;p&gt;Not only am I able to conditionally manage objects in the cluster based on available APIs, using Jinja2 templates, in my Deployment template I can use OpenShift&amp;rsquo;s DeploymentConfig if the &lt;code&gt;apps.openshift.io&lt;/code&gt; API is present in the cluster. Here is my &lt;code&gt;templates/deployment.yml.j2&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---

{% if &#39;apps.openshift.io&#39; in api_groups %}
apiVersion: apps.openshift.io/v1
kind: DeploymentConfig
{% else %}
apiVersion: apps/v1
kind: Deployment
{% endif %}
metadata:
  name: {{ name }}
  namespace: {{ namespace }}
  labels:
    app: {{ name }}
    service: {{ name }}
spec:
  replicas: {{ size }}
{% if &#39;apps.openshift.io&#39; in api_groups %}
  selector:
    app: {{ name }}
    service: {{ name }}
{% else %}
  selector:
    matchLabels:
      app: {{ name }}
      service: {{ name }}
{% endif %}
  template:
    metadata:
      labels:
        app: {{ name }}
        service: {{ name }}
    spec:
      containers:
      - image: {{ image }}
        name: hello-world
        ports:
        - containerPort: 8080
          protocol: TCP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My &lt;code&gt;templates/service.yml.j2&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---

apiVersion: v1
kind: Service
metadata:
  name: {{ name }}
  namespace: {{ namespace }}
  labels:
    app: {{ name }}
    service: {{ name }}
spec:
  ports:
  - name: web
    port: 8080
    protocol: TCP
    targetPort: 8080
  selector:
    app: {{ name }}
    service: {{ name }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, my &lt;code&gt;templates/route.yml.j2&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---

apiVersion: route.openshift.io/v1
kind: Route
metadata:
  name: {{ name }}
  namespace: {{ namespace }}
  labels:
    app: {{ name }}
    service: {{ name }}
spec:
  port:
    targetPort: web
  to:
    kind: Service
    name: {{ name }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I skipped over the creation of &lt;code&gt;meta/main.yml&lt;/code&gt;, but you can find mine &lt;a href=&#34;https://github.com/djzager/ansible-role-hello-world-k8s/blob/ao-galaxy-blog/meta/main.yml&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now I have an Ansible Role that manages my Hello World application in Kubernetes and can take advantage of APIs if available in the cluster. Using the &lt;code&gt;k8s&lt;/code&gt; module with the dynamic client simplifies managing objects in Kubernetes. I hope that this Role helps to showcase the power of Ansible when working with Kubernetes.&lt;/p&gt;

&lt;h1 id=&#34;hello-galaxy-meet-kubernetes&#34;&gt;Hello Galaxy, Meet Kubernetes&lt;/h1&gt;

&lt;p&gt;Many of the Ansible Roles published to Galaxy are for server configuration and application management. My wish is for Galaxy to be inundated with Roles managing Kubernetes applications.&lt;/p&gt;

&lt;p&gt;Once I have pushed my &lt;a href=&#34;https://github.com/djzager/ansible-role-hello-world-k8s/&#34; target=&#34;_blank&#34;&gt;Role to GitHub&lt;/a&gt;, all I need to do is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Log into Ansible Galaxy, giving it access to my GitHub repositories.&lt;/li&gt;
&lt;li&gt;Import my role&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;My &lt;code&gt;hello_world_k8s&lt;/code&gt; role is now publicly available in Galaxy &lt;a href=&#34;https://galaxy.ansible.com/djzager/hello_world_k8s&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;hello-ansible-operator-meet-galaxy&#34;&gt;Hello Ansible Operator, Meet Galaxy&lt;/h1&gt;

&lt;p&gt;If you have a look at my &lt;a href=&#34;https://github.com/djzager/ansible-role-hello-world-k8s/&#34; target=&#34;_blank&#34;&gt;Hello World project in GitHub&lt;/a&gt; you may notice that I added the necessary pieces to make an Ansible Operator. These are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;a href=&#34;https://github.com/djzager/ansible-role-hello-world-k8s/blob/ao-galaxy-blog/watches.yaml&#34; target=&#34;_blank&#34;&gt;watches file&lt;/a&gt; that provides a mapping of Kubernetes &lt;a href=&#34;https://kubernetes.io/docs/concepts/api-extension/custom-resources/&#34; target=&#34;_blank&#34;&gt;Custom Resources&lt;/a&gt; to Ansible Roles or Playbooks.&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;https://github.com/djzager/ansible-role-hello-world-k8s/blob/ao-galaxy-blog/build/Dockerfile&#34; target=&#34;_blank&#34;&gt;Dockerfile&lt;/a&gt; for building my Operator.&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;https://github.com/djzager/ansible-role-hello-world-k8s/tree/ao-galaxy-blog/deploy&#34; target=&#34;_blank&#34;&gt;deploy directory&lt;/a&gt; with the Kubernetes specific objects necessary to run my Operator.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Want to know more about building your own Ansible Operator? Check out the &lt;a href=&#34;https://github.com/operator-framework/operator-sdk/blob/master/doc/ansible/user-guide.md&#34; target=&#34;_blank&#34;&gt;User Guide&lt;/a&gt;. But I promised to build an Ansible Operator using my Role published to Galaxy, all I &lt;strong&gt;really&lt;/strong&gt; need is a Dockerfile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM quay.io/operator-framework/ansible-operator

RUN ansible-galaxy install djzager.hello_world_k8s

RUN echo $&#39;--- \n\
- version: v1alpha1\n\
  group: examples.djzager.io\n\
  kind: HelloWorld\n\
  role: /opt/ansible/roles/djzager.hello_world_k8s&#39; &amp;gt; ${HOME}/watches.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then building an Operator is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker build -t hello-world-operator -f Dockerfile .
Sending build context to Docker daemon 157.2 kB
Step 1/3 : FROM quay.io/operator-framework/ansible-operator
latest: Pulling from operator-framework/ansible-operator
Digest: sha256:1156066a05fb1e1dd5d4286085518e5ce15acabfff10a8145eef8da088475db3
Status: Downloaded newer image for quay.io/water-hole/ansible-operator:latest
 ---&amp;gt; 39cc1d19649d
Step 2/3 : RUN ansible-galaxy install djzager.hello_world_k8s
 ---&amp;gt; Running in 83ba8c21f233
- downloading role &#39;hello_world_k8s&#39;, owned by djzager
- downloading role from https://github.com/djzager/ansible-role-hello-world-k8s/archive/master.tar.gz
- extracting djzager.hello_world_k8s to /opt/ansible/roles/djzager.hello_world_k8s
- djzager.hello_world_k8s (master) was installed successfully
Removing intermediate container 83ba8c21f233
 ---&amp;gt; 2f303b45576c
Step 3/3 : RUN echo $&#39;--- \n- version: v1alpha1\n  group: examples.djzager.io\n    kind: HelloWorld\n      role: /opt/ansible/roles/djzager.hello_world_k8s&#39; &amp;gt; ${HOME}/watches.yaml
 ---&amp;gt; Running in cced495a9cb4
Removing intermediate container cced495a9cb4
 ---&amp;gt; 5827bc3c1ca3
Successfully built 5827bc3c1ca3
Successfully tagged hello-world-operator:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Admittedly, in order to &lt;strong&gt;use&lt;/strong&gt; this Operator you will want to use the &lt;a href=&#34;https://github.com/djzager/ansible-role-hello-world-k8s/tree/ao-galaxy-blog/deploy&#34; target=&#34;_blank&#34;&gt;deploy bits&lt;/a&gt; from my project to create the Service Account, Role and Role Binding, Custom Resource Definition, as well as deploy the Operator. Once the Operator is deployed, create the Custom Resource to get an instance of the Hello World application:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: examples.djzager.io/v1alpha1
kind: HelloWorld
metadata:
  name: example-helloworld
  namespace: default
spec:
  size: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;namespace-scoped-vs-cluster-scoped-operators&#34;&gt;Namespace Scoped vs Cluster Scoped Operators&lt;/h2&gt;

&lt;p&gt;I previously suggested that you look at my &lt;a href=&#34;https://github.com/djzager/ansible-role-hello-world-k8s/tree/ao-galaxy-blog/deploy&#34; target=&#34;_blank&#34;&gt;deploy directory&lt;/a&gt; to find the Kubernetes specific objects necessary to run an Operator. If you look closely you will see 3 things that will constrain this Operator to only manage Custom Resources in the namespace where it is deployed:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;WATCH_NAMESPACE&lt;/code&gt; environment variable in &lt;a href=&#34;https://github.com/djzager/ansible-role-hello-world-k8s/blob/ao-galaxy-blog/deploy/operator.yaml#L25-L28&#34; target=&#34;_blank&#34;&gt;operator.yaml&lt;/a&gt; tells the operator where to watch Custom Resources.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/djzager/ansible-role-hello-world-k8s/blob/ao-galaxy-blog/deploy/role.yaml#L2&#34; target=&#34;_blank&#34;&gt;role.yaml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/djzager/ansible-role-hello-world-k8s/blob/ao-galaxy-blog/deploy/role_binding.yaml#L1&#34; target=&#34;_blank&#34;&gt;role_binding&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is helpful for developing an operator. If I wanted to make my application available to all users of the cluster, though, I would need the help of a cluster admin. I would need to:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create a &lt;code&gt;ClusterRole&lt;/code&gt; instead of a &lt;code&gt;Role&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Create the operator &lt;code&gt;ServiceAccount&lt;/code&gt; in the namespace where the operator will be deployed.&lt;/li&gt;
&lt;li&gt;Create a &lt;code&gt;ClusterRoleBinding&lt;/code&gt; that binds the namespaced &lt;code&gt;ServiceAccount&lt;/code&gt; to the &lt;code&gt;ClusterRole&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Deploy the operator with the &lt;code&gt;WATCH_NAMESPACE&lt;/code&gt; environment variable unset (or &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Doing so would allow other users of the cluster to deploy instances of my Hello World Application. If this sounds interesting, you should check out the &lt;a href=&#34;https://github.com/operator-framework/operator-lifecycle-manager/&#34; target=&#34;_blank&#34;&gt;Operator Lifecycle Manager&lt;/a&gt; (also a part of the Operator Framework).&lt;/p&gt;

&lt;h1 id=&#34;next-steps&#34;&gt;Next Steps&lt;/h1&gt;

&lt;p&gt;The Hello World application in this post was designed to be intentionally simple but there are still things I could do to make it more robust.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Use &lt;a href=&#34;https://github.com/operator-framework/operator-sdk/&#34; target=&#34;_blank&#34;&gt;Operator SDK&lt;/a&gt; - I skipped this piece in this post to highlight how easy it can be to go from an Ansible Role to an Operator. Using this role with the SDK (think &lt;code&gt;operator-sdk new&lt;/code&gt;) would be something I would suggest to do, and most likely necessary, for subsequent steps.&lt;/li&gt;
&lt;li&gt;Validation - right now if a user were to create a CR with &lt;code&gt;size: abc&lt;/code&gt; the deployment creation step would simply fail. It would be better for us to catch errors in the spec before attempting to do work.&lt;/li&gt;
&lt;li&gt;Lifecycle - in more complex examples this could be handling version upgrades. In a scenario like this one, where there is only one version of the Hello World application, we could detect when the running container image is out of date when compared to what is available in the corresponding container registry and update the running instances.&lt;/li&gt;
&lt;li&gt;Testing - &lt;a href=&#34;https://github.com/ansible/molecule&#34; target=&#34;_blank&#34;&gt;Molecule&lt;/a&gt; helps with the development and testing of Ansible Roles.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/operator-framework/operator-lifecycle-manager/&#34; target=&#34;_blank&#34;&gt;Operator Lifecycle Manager&lt;/a&gt; - is a toolkit for managing Operators. Integration with OLM would allow us to handle installation and upgrades to our Operator.&lt;/li&gt;
&lt;li&gt;Status - we could enable the status subresource on our Hello World CRD and use &lt;code&gt;k8s_status&lt;/code&gt; module, provided in the Ansible Operator image, to include status information to the Custom Resource.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Now that I have shown you how to build an Ansible Role to manage an application in Kubernetes, publish to Ansible Galaxy, and use that role with Ansible Operator, I hope that you will:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Use the &lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/k8s_module.html&#34; target=&#34;_blank&#34;&gt;Ansible &lt;code&gt;k8s&lt;/code&gt; module&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Start flooding &lt;a href=&#34;https://galaxy.ansible.com&#34; target=&#34;_blank&#34;&gt;Ansible Galaxy&lt;/a&gt; with roles managing Kubernetes applications.&lt;/li&gt;
&lt;li&gt;Check out &lt;a href=&#34;https://github.com/operator-framework/operator-sdk&#34; target=&#34;_blank&#34;&gt;Operator SDK&lt;/a&gt; and join us on the &lt;a href=&#34;https://groups.google.com/forum/#!forum/operator-framework&#34; target=&#34;_blank&#34;&gt;Operator Framework mailing list&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;üëç&lt;/p&gt;
</content>
      
    </item>
    
    <item>
      <title>Personal GitHub Pages with Hugo&#39;s Website Generator</title>
      <link>https://djzager.github.io/posts/1-hugo-and-ghpages/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      <author>David Zager</author>
      <guid>https://djzager.github.io/posts/1-hugo-and-ghpages/</guid>
      <description>Starting a blog with Hugo and Personal GitHub Pages</description>
      
      <content>

&lt;p&gt;I am excited to maintain a blog and there seems no better way to
get things rolling than to document the start. When I started playing with
&lt;a href=&#34;https://gohugo.io&#34; target=&#34;_blank&#34;&gt;Hugo&lt;/a&gt; and thinking about how I would integrate it with
Personal GitHub Pages, I assumed it would be a trivial operation. Turns out
there are a few gotchas worth documenting. This post will simply cover
creating a static website using Hugo&amp;rsquo;s Website Generator and making it work
with &lt;a href=&#34;https://pages.github.com/&#34; target=&#34;_blank&#34;&gt;Personal GitHub Pages&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;

&lt;p&gt;If you have not seen Jente Hidskes&amp;rsquo; &lt;a href=&#34;https://hjdskes.github.io/blog/deploying-hugo-on-personal-gh-pages/&#34; target=&#34;_blank&#34;&gt;original article&lt;/a&gt;
on deploying personal GitHub Pages or &lt;a href=&#34;https://hjdskes.github.io/blog/update-deploying-hugo-on-personal-gh-pages/&#34; target=&#34;_blank&#34;&gt;his follow-up&lt;/a&gt;
then you should check those out first. When I originally ventured down
this path I found &lt;a href=&#34;https://gohugo.io/hosting-and-deployment/hosting-on-github/&#34; target=&#34;_blank&#34;&gt;Hugo&amp;rsquo;s hosting on GitHub&lt;/a&gt;
article, changed the &lt;code&gt;publishDir&lt;/code&gt; value in &lt;code&gt;config.toml&lt;/code&gt;, and was very
dissappointed when it did not work. Unfortunately, that method only works for project pages.
Personal GitHub pages (built with Hugo), like this, must start with a valid
&lt;code&gt;index.html&lt;/code&gt; file at the master branch&amp;rsquo;s root.&lt;/p&gt;

&lt;h2 id=&#34;configuration&#34;&gt;Configuration&lt;/h2&gt;

&lt;p&gt;In the case that you are starting off fresh, like I was, then this part is
fairly simple. If not, I recommend you use Jente Hidskes&amp;rsquo; &lt;a href=&#34;https://hjdskes.github.io/blog/update-deploying-hugo-on-personal-gh-pages/&#34; target=&#34;_blank&#34;&gt;updated guide&lt;/a&gt;,
keeping in mind that you must change the &amp;ldquo;default&amp;rdquo; branch away from master at
&lt;code&gt;https://github.com/$GITHUB_USERNAME/$GITHUB_USERNAME.github.io/settings/branches&lt;/code&gt;
before trying to delete it; I did not and I was
properly punished for not reading his &lt;a href=&#34;https://hjdskes.github.io/blog/deploying-hugo-on-personal-gh-pages/&#34; target=&#34;_blank&#34;&gt;original article&lt;/a&gt;
first. Our goals are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Have a &lt;code&gt;$SOURCE&lt;/code&gt; branch for all source files, I think of this as my Hugo workspace.&lt;/li&gt;
&lt;li&gt;Publish the contents of our &lt;code&gt;publishDir&lt;/code&gt; (&lt;code&gt;public/&lt;/code&gt; by default) to the
master branch.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; I did not install the hugo binary on my system. I instead used a
&lt;a href=&#34;https://hub.docker.com/r/jguyomard/hugo-builder/&#34; target=&#34;_blank&#34;&gt;hugo-builder docker image&lt;/a&gt;.
You can see the two ways I run the image below but for the remainder of the
post I will simply use &lt;code&gt;hugo&lt;/code&gt; as it would look if I had installed the binary.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# When running a hugo command
$ docker run --rm -it -v $PWD:/src:Z -u hugo \
    jguyomard/hugo-builder hugo ${ARGS}

# When starting the hugo server
$ docker run --rm -it -v $PWD:/src -p 1313:1313 -u hugo \
    jguyomard/hugo-builder hugo server -v --buildDrafts -w --bind=0.0.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;initial-setup&#34;&gt;Initial Setup&lt;/h3&gt;

&lt;p&gt;Looking at the &lt;code&gt;setup.sh&lt;/code&gt;
&lt;a href=&#34;https://gist.github.com/djzager/b80a131acb4cabf33fac4f385c1987d7/raw/28e860cc3445ad81756eb028f7c6c154d8bf0097/setup.sh&#34; target=&#34;_blank&#34;&gt;gist&lt;/a&gt;
below, you will see that it covers the steps necessary to create my Hugo
workspace &lt;strong&gt;and&lt;/strong&gt; use the &lt;code&gt;public/&lt;/code&gt; directory as my &lt;code&gt;publishDir&lt;/code&gt; using
&lt;a href=&#34;https://git-scm.com/docs/git-worktree&#34; target=&#34;_blank&#34;&gt;git worktree&lt;/a&gt;. This was my first
experience using worktree&amp;rsquo;s and I found it a clever way to make this workflow
possible.&lt;/p&gt;

&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/djzager/b80a131acb4cabf33fac4f385c1987d7.js?file=setup.sh&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;add-content-and-styling&#34;&gt;Add Content and Styling&lt;/h3&gt;

&lt;p&gt;The two primary tasks that remain are to add content and styling to our
website. Adding new content is as simple as &lt;code&gt;hugo new posts/$POST_NAME.md&lt;/code&gt;
(assuming you are using &lt;a href=&#34;https://gohugo.io/content-management/formats/&#34; target=&#34;_blank&#34;&gt;Hugo&amp;rsquo;s
Markdown&lt;/a&gt;) and start writing.
Once you have content, but before you publish, you&amp;rsquo;ll want to have a look at
&lt;a href=&#34;https://themes.gohugo.io/&#34; target=&#34;_blank&#34;&gt;Hugo&amp;rsquo;s Theme List&lt;/a&gt; and install one. When I
installed the &lt;a href=&#34;https://themes.gohugo.io/kiss/&#34; target=&#34;_blank&#34;&gt;KISS theme&lt;/a&gt; I just added it
as a submodule (see below) and update my &lt;code&gt;config.toml&lt;/code&gt; with the name of the
theme (&amp;ldquo;kiss&amp;rdquo;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git submodule add https://github.com/ribice/kiss.git themes/kiss
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;publish&#34;&gt;Publish&lt;/h2&gt;

&lt;p&gt;All that is left now is to &amp;ldquo;publish&amp;rdquo; our contents by running &lt;code&gt;hugo&lt;/code&gt; and pushing
the modified contents of our &lt;code&gt;publishDir&lt;/code&gt; to our master branch.&lt;/p&gt;

&lt;p&gt;First we build the site:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, move into the &lt;code&gt;publishDir&lt;/code&gt; (&lt;code&gt;public/&lt;/code&gt; for me), and push our changes to
master:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd $PUBLISH_DIR
git add *
git commit -m &amp;quot;Site build $(date)&amp;quot;
git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see all green from Github at
&lt;code&gt;https://github.com/$GITHUB_USERNAME/$SITE_NAME/settings&lt;/code&gt;, letting you know
that you site has successfully been published.&lt;/p&gt;

&lt;h3 id=&#34;automation&#34;&gt;Automation&lt;/h3&gt;

&lt;p&gt;Once you get over the initial hurdle of starting, it is important to find a
workflow that works best for you. Where some people like to write shell
scripts, I prefer to write a simple &lt;code&gt;Makefile&lt;/code&gt; that covers everything from
running &lt;code&gt;hugo server&lt;/code&gt; for when I&amp;rsquo;m writing, to building, and
publishing the content of the site. Feel free to copy, take inspiration from
the gist below, or go straight to
&lt;a href=&#34;https://github.com/djzager/djzager.github.io&#34; target=&#34;_blank&#34;&gt;the source&lt;/a&gt;.&lt;/p&gt;

&lt;script type=&#34;application/javascript&#34; src=&#34;//gist.github.com/djzager/b80a131acb4cabf33fac4f385c1987d7.js?file=Makefile&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In this post we covered getting started with personal
&lt;a href=&#34;https://pages.github.com/&#34; target=&#34;_blank&#34;&gt;GitHub Pages&lt;/a&gt; using
&lt;a href=&#34;https://gohugo.io/&#34; target=&#34;_blank&#34;&gt;Hugo&amp;rsquo;s static web site generator&lt;/a&gt;,
publishing our content on the master branch using
&lt;a href=&#34;https://git-scm.com/docs/git-worktree&#34; target=&#34;_blank&#34;&gt;git working tree&amp;rsquo;s&lt;/a&gt;,
maintaining the source files on a separate branch
to keep our sanity, and automating our workflow using a &lt;code&gt;Makefile&lt;/code&gt;. Starting a
blog was the goal and Hugo + GitHub Pages have allowed that to happen.&lt;/p&gt;

&lt;p&gt;üëç&lt;/p&gt;
</content>
      
    </item>
    
  </channel>
</rss>